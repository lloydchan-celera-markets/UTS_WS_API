package com.vectails.data;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;

import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.celera.core.common.GenericFactory;
import com.celera.core.common.IGenericFactory;
import com.vectails.data.IXmlParser.IXmlNode;

import sun.reflect.generics.factory.GenericsFactory;

public interface IXmlParser 
{
	// static public <T> void parseXmlElement(Element root, T t) { // root =
	// <Legs>
	// public default <T> void parseXmlElement(Element root, T t) { // root =
	// <Legs>

	public default Object create()
	{
		Object o = null;
		try
		{
			final Constructor<?> ctr = getClass().getConstructor();
			o = ctr.newInstance();
		} catch (Exception e)
		{
			e.printStackTrace();
		}
		return o;
	}

	public default void parseAttribute(Element root)
	{
		NamedNodeMap m = root.getAttributes();
		int len = m.getLength();
		String nodeName;

		for (int j = 0; j < len; j++)
		{
			Node n = m.item(j);
			nodeName = n.getNodeName();
			try
			{
				Field field = this.getClass().getDeclaredField(nodeName);
				Method setter = this.getClass().getMethod("set" + nodeName, field.getType());
				setter.invoke(this, n.getTextContent());
			} catch (NoSuchFieldException e)
			{
				System.out.println("NoSuchFieldException:" + e.getMessage() + "," + nodeName);
				e.printStackTrace();
			} catch (IllegalArgumentException e)
			{
				System.out.println("IllegalArgumentException:" + e.getMessage() + "," + nodeName);
				e.printStackTrace();
			} catch (Exception e)
			{
				e.printStackTrace();
			}
		}
	}

	public default void parseLeaveNodes(Element root)
	{ // root = <Legs>

		String nodeName = null;

		NodeList nodes = root.getChildNodes();
		int lenNodes = nodes.getLength();
		for (int l = 0; l < lenNodes; l++)
		{ // elements
			Node n = nodes.item(l);

			if (n.getNodeType() == Node.ELEMENT_NODE)
			{
				nodeName = n.getNodeName();
				try
				{
					Field field = this.getClass().getDeclaredField(nodeName);
					if (Collection.class.isAssignableFrom(field.getType()))
					{
						parseLeaveNodes((Element) n);
					} else
					{
						Method setter = this.getClass().getMethod("set" + nodeName,
								// "set" + nodeName.substring(0,
								// 1).toUpperCase() +
								// nodeName.substring(1),
								field.getType());
						setter.invoke(this, n.getTextContent());
					}

				} catch (NoSuchFieldException e)
				{
					System.out.println("NoSuchFieldException:" + e.getMessage() + "," + nodeName);
					e.printStackTrace();
				} catch (Exception e)
				{
					e.printStackTrace();
				}
			}
		}
	}

	public interface IXmlNode<T> 
	{
		public default void parseAttribute(Element root)
		{
			NamedNodeMap m = root.getAttributes();
			int len = m.getLength();
			String nodeName;

			for (int j = 0; j < len; j++)
			{
				Node n = m.item(j);
				nodeName = n.getNodeName();
				try
				{
					Field field = this.getClass().getDeclaredField(nodeName);
					Method setter = this.getClass().getMethod("set" + nodeName, field.getType());
					setter.invoke(this, n.getTextContent());
				} catch (NoSuchFieldException e)
				{
					System.out.println("NoSuchFieldException:" + e.getMessage() + "," + nodeName);
					e.printStackTrace();
				} catch (IllegalArgumentException e)
				{
					System.out.println("IllegalArgumentException:" + e.getMessage() + "," + nodeName);
					e.printStackTrace();
				} catch (Exception e)
				{
					e.printStackTrace();
				}
			}
		}
		
		public default void parseNode(Element root) // root = <Legs>
		{
			parseAttribute(root);

			String nodeName = root.getNodeName();

			NodeList nodes = root.getChildNodes();
			int lenNodes = nodes.getLength();
			for (int l = 0; l < lenNodes; l++)
			{ // elements
				Node n = nodes.item(l);

				if (n.getNodeType() == Node.ELEMENT_NODE)
				{
					nodeName = n.getNodeName();
					try
					{
						Field field = this.getClass().getDeclaredField(nodeName);
						field.setAccessible(true);
						
						if (Collection.class.isAssignableFrom(field.getType()))
						{
//							IXmlNode o = (IXmlNode) GenericFactory.build("com.vectails.data.IXmlParser$" + nodeName);
							
//							((IGenericFactory) this).setClass(Class.forName("com.vectails.data.IXmlParser$" + nodeName));
							IXmlNode o = (IXmlNode)((IGenericFactory) this).build();
							o.parseNode((Element) n);

							Object obj = field.get(this);
							Method m = field.getType().getDeclaredMethod("add", Object.class);
							m.invoke(obj, o);
						} else
						{
							Method setter = this.getClass().getMethod("set" + nodeName, field.getType());
							setter.invoke(this, n.getTextContent());
						}
					} catch (Exception e)
					{
						e.printStackTrace();
					}
				}
			}
		}
//		public default void parseNode(Element root)
//		{ // root = <Legs>
//			
//			String nodeName = root.getNodeName();
//			
//			NodeList nodes = root.getChildNodes();
//			int lenNodes = nodes.getLength();
//			for (int l = 0; l < lenNodes; l++)
//			{ // elements
//				Node n = nodes.item(l);
//				
//				if (n.getNodeType() == Node.ELEMENT_NODE)
//				{
//					nodeName = n.getNodeName();
//					try
//					{
//						Class<?> clazz = Class.forName("com.vectails.data.IXmlParser$" + nodeName);
//						if (IGenericFactory.class.isAssignableFrom(clazz) && IXmlNode.class.isAssignableFrom(clazz))
//						{
//							try
//							{
//								IGenericFactory o = (IGenericFactory) clazz.newInstance();
//								((IXmlNode) o).parseNode((Element) n);
//								System.out.println(nodeName);
//							} catch (InstantiationException | IllegalAccessException e)
//							{
//								e.printStackTrace();
//							}
//						}
//					} catch (ClassNotFoundException e)
//					{
//						e.printStackTrace();
//					}
//				}
//			}
//		}
	}

	public class UtsDirectAccessResponse extends GenericFactory implements IXmlNode 
	{
		public UtsDirectAccessResponse()
		{
			super(IXmlParser.DerivativeTypes.class);
		}

		List<IXmlNode> DerivativeTypes = new ArrayList<IXmlNode>();
		List<IXmlNode> Currencies = new ArrayList<IXmlNode>();
		List<IXmlNode> Underlyings = new ArrayList<IXmlNode>();
		List<IXmlNode> IndexFutures = new ArrayList<IXmlNode>();
		List<IXmlNode> AllowedQuoteCreators = new ArrayList<IXmlNode>();
		List<IXmlNode> Addressees = new ArrayList<IXmlNode>();

		public List<IXmlNode> getDerivativeTypes()
		{
			return DerivativeTypes;
		}

		public List<IXmlNode> getCurrencies()
		{
			return Currencies;
		}

		@Override
		public void parseNode(Element root) // root = <Legs>
		{
			parseAttribute(root);

			String nodeName = root.getNodeName();

			NodeList nodes = root.getChildNodes();
			int lenNodes = nodes.getLength();
			for (int l = 0; l < lenNodes; l++)
			{ // elements
				Node n = nodes.item(l);

				if (n.getNodeType() == Node.ELEMENT_NODE)
				{
					nodeName = n.getNodeName();
					try
					{
						Field field = this.getClass().getDeclaredField(nodeName);
						field.setAccessible(true);
						
						if (Collection.class.isAssignableFrom(field.getType()))
						{
//							IXmlNode o = null;
//							switch (nodeName) {
//							case "AllowedQuoteCreators":
//								o = (IXmlNode)((IGenericFactory) this).build("com.vectails.data.IXmlParser$AllowedQuoteCreators");	
//								break;
//							case "IndexFutures":
//								o = (IXmlNode)((IGenericFactory) this).build("com.vectails.data.IXmlParser$IndexFutures");	
//								break;
//							case "Underlyings":
//								o = (IXmlNode)((IGenericFactory) this).build("com.vectails.data.IXmlParser$Underlyings");	
//								break;
//							case "Currencies":
//								o = (IXmlNode)((IGenericFactory) this).build("com.vectails.data.IXmlParser$Currencies");	
//								break;
//							case "DerivativeTypes":
//								o = (IXmlNode)((IGenericFactory) this).build("com.vectails.data.IXmlParser$DerivativeTypes");	
//								break;
//							}
							IXmlNode o = (IXmlNode)((IGenericFactory) this).build("com.vectails.data.IXmlParser$" + nodeName);	
							o.parseNode((Element) n);

							Object obj = field.get(this);
							Method m = field.getType().getDeclaredMethod("add", Object.class);
							m.invoke(obj, o);
						} else
						{
							Method setter = this.getClass().getMethod("set" + nodeName, field.getType());
							setter.invoke(this, n.getTextContent());
						}
					} catch (Exception e)
					{
						e.printStackTrace();
					}
				}
			}
		}
	}

	public class AllowedQuoteCreators extends GenericFactory implements IXmlNode
	{
		public AllowedQuoteCreators()
		{
			super(IXmlParser.QuoteCreator.class);
		}

		List<IXmlNode> QuoteCreator = new ArrayList<IXmlNode>();
	}
	
	public class QuoteCreator extends GenericFactory implements IXmlNode
	{
		private String Code = null; 
		List<SubscribedUnderlyings> SubscribedUnderlyings = new ArrayList<SubscribedUnderlyings>();
		
		public QuoteCreator(Class clazz)
		{
			super(IXmlParser.QuoteCreator.class);
		}

		public String getCode()
		{
			return Code;
		}

		public void setCode(String code)
		{
			Code = code;
		}
	}
	
	public class SubscribedUnderlyings extends GenericFactory implements IXmlNode
	{
		List<Underlyings> Underlyings = new ArrayList<Underlyings>();
		
		public SubscribedUnderlyings()
		{
			super(IXmlParser.UnderlyingType.class);
		}
	}
	
	public class IndexFutures extends GenericFactory implements IXmlNode
	{
		public IndexFutures()
		{
			super(IXmlParser.IndexFuture.class);
		}

		List<IXmlNode> IndexFuture = new ArrayList<IXmlNode>();
	}
	
	public class IndexFuture extends GenericFactory implements IXmlNode
	{
		public IndexFuture()
		{
			super(IXmlParser.IndexFuture.class);
		}

		private String ExpiryDate = null;
		private String IndexCode = null;
		private String IndexFinancialMarketCode = null;
		private String IndexUnderlyingTypeCode = null;
		private String LastUpdateDateTime = null;
		
		public void setExpiryDate(String expiryDate) {
			ExpiryDate = expiryDate;
		}

		public void setIndexCode(String indexCode) {
			IndexCode = indexCode;
		}

		public void setIndexFinancialMarketCode(String indexFinancialMarketCode) {
			IndexFinancialMarketCode = indexFinancialMarketCode;
		}

		public void setIndexUnderlyingTypeCode(String indexUnderlyingTypeCode) {
			IndexUnderlyingTypeCode = indexUnderlyingTypeCode;
		}

		public void setLastUpdateDateTime(String lastUpdateDateTime) {
			LastUpdateDateTime = lastUpdateDateTime;
		}

		public String getExpiryDate()
		{
			return ExpiryDate;
		}

		public String getIndexCode()
		{
			return IndexCode;
		}

		public String getIndexFinancialMarketCode()
		{
			return IndexFinancialMarketCode;
		}

		public String getIndexUnderlyingTypeCode()
		{
			return IndexUnderlyingTypeCode;
		}

		public String getLastUpdateDateTime()
		{
			return LastUpdateDateTime;
		}
	}
	
	public class Underlyings extends GenericFactory implements IXmlNode 
	{
		List<IXmlNode> Underlying = new ArrayList<IXmlNode>();
		
		public Underlyings()
		{
			super(IXmlParser.Underlying.class);
		}
	}
	
	public class Underlying extends GenericFactory implements IXmlNode
	{
		public Underlying()
		{
			super(IXmlParser.Underlying.class);
		}

		private String FinancialMarketCode = null;
		private String UnderlyingTypeCode = null;
		private String Code = null;
		private String Name = null;
		private String Reuters = null;
		private String ISIN = null;
		private String Bloomberg = null;
		private String IsObsolete = null;
		private String HasFutures = null;
		private String LastUpdateDateTime = null;
		
		public void setCode(String code) {
			Code = code;
		}

		public void setFinancialMarketCode(String financialMarketCode) {
			FinancialMarketCode = financialMarketCode;
		}

		public void setUnderlyingTypeCode(String underlyingTypeCode) {
			UnderlyingTypeCode = underlyingTypeCode;
		}

		public void setReuters(String reuters) {
			Reuters = reuters;
		}

		public void setISIN(String iSIN) {
			ISIN = iSIN;
		}

		public void setBloomberg(String bloomberg) {
			Bloomberg = bloomberg;
		}

		public void setIsObsolete(String isObsolete) {
			IsObsolete = isObsolete;
		}

		public void setHasFutures(String hasFutures) {
			HasFutures = hasFutures;
		}

		public void setLastUpdateDateTime(String lastUpdateDateTime) {
			LastUpdateDateTime = lastUpdateDateTime;
		}

		public void setName(String name) {
			Name = name;
		}

		public String getFinancialMarketCode()
		{
			return FinancialMarketCode;
		}

		public String getUnderlyingTypeCode()
		{
			return UnderlyingTypeCode;
		}

		public String getCode()
		{
			return Code;
		}

		public String getName()
		{
			return Name;
		}

		public String getReuters()
		{
			return Reuters;
		}

		public String getISIN()
		{
			return ISIN;
		}

		public String getBloomberg()
		{
			return Bloomberg;
		}

		public String getIsObsolete()
		{
			return IsObsolete;
		}

		public String getHasFutures()
		{
			return HasFutures;
		}

		public String getLastUpdateDateTime()
		{
			return LastUpdateDateTime;
		}
	}
	
	public class Addressees extends GenericFactory implements IXmlNode 
	{
		List<IXmlNode> Addressee = new ArrayList<IXmlNode>();
		
		public Addressees()
		{
			super(IXmlParser.Addressee.class);
		}
	}
	
	public class Addressee implements IXmlNode
	{
		private String EntityCode = null;
		private String Code = null;
		private String TypeCode = null;
		private String Name = null;
		private String ShortCode = null;
		private String LastUpdateDateTime = null;

		public void setEntityCode(String entityCode)
		{
			EntityCode = entityCode;
		}

		public void setCode(String code)
		{
			Code = code;
		}

		public void setTypeCode(String typeCode)
		{
			TypeCode = typeCode;
		}

		public void setName(String name)
		{
			Name = name;
		}

		public void setShortCode(String shortCode)
		{
			ShortCode = shortCode;
		}

		public void setLastUpdateDateTime(String lastUpdateDateTime)
		{
			LastUpdateDateTime = lastUpdateDateTime;
		}

		public String getEntityCode()
		{
			return EntityCode;
		}

		public String getCode()
		{
			return Code;
		}

		public String getTypeCode()
		{
			return TypeCode;
		}

		public String getName()
		{
			return Name;
		}

		public String getShortCode()
		{
			return ShortCode;
		}

		public String getLastUpdateDateTime()
		{
			return LastUpdateDateTime;
		}
	}
	
	public class Currencies extends GenericFactory implements IXmlNode 
	{
		public Currencies()
		{
			super(IXmlParser.Currency.class);
		}

		List<IXmlNode> Currency = new ArrayList<IXmlNode>();
	}
	
	public class Currency extends GenericFactory implements IXmlNode
	{
		public Currency()
		{
			super(IXmlParser.Currency.class);
		}

		private String Code;
		private String Name;
		
		public void setCode(String code) {
			Code = code;
		}

		public void setName(String name) {
			Name = name;
		}

		public String getCode()
		{
			return Code;
		}

		public String getName()
		{
			return Name;
		}
	}
	
	public class DerivativeTypes<DerivativeType> extends GenericFactory implements IXmlNode
	{
		public DerivativeTypes()
		{
			super(IXmlParser.DerivativeType.class);
		}

//		@Override
//		public String toString() {
//			StringBuilder sb = new StringBuilder();
//			sb.append("DerivativeTypes [");
//			for (IXmlNode l: DerivativeType) {
//				sb.append(l.toString()).append(", ");
//			}
//			sb.append("]");
//			return sb.toString();
//		}
		
		List<IXmlNode> DerivativeType = new ArrayList<IXmlNode>();

		public List<IXmlNode> getDerivativeType()
		{
			return DerivativeType;
		}

//		@Override
//		public void parseNode(Element root) // root = <Legs>
//		{
//			parseAttribute(root);
//			
//			String nodeName = root.getNodeName();
//			NodeList nodes = root.getChildNodes();
//			int lenNodes = nodes.getLength();
//			for (int l = 0; l < lenNodes; l++)
//			{ // elements
//				Node n = nodes.item(l);
//
//				if (n.getNodeType() == Node.ELEMENT_NODE)
//				{
//					nodeName = n.getNodeName();
//					try
//					{
////						Class<?> clazz = Class.forName("com.vectails.data.IXmlParser$" + nodeName);
////						if (IGenericFactory.class.isAssignableFrom(clazz))
////						{
//							Field field;
//							field = this.getClass().getDeclaredField(nodeName);
//
//							if (Collection.class.isAssignableFrom(field.getType()))
//							{
//								IXmlNode o = (IXmlNode) new IXmlParser.DerivativeType();
//								o.parseNode((Element) n);
//								
//								Object obj = field.get(this);
//								Method m = field.getType().getDeclaredMethod("add", Object.class);
//								m.invoke(obj, o);
//							} else
//							{
//								Method setter = this.getClass().getMethod("set" + nodeName, field.getType());
//								setter.invoke(this, n.getTextContent());
//							}
////						}
//					} catch (Exception e)
//					{
//						// TODO Auto-generated catch block
//						e.printStackTrace();
//					}
//				}
//			}
//		}
	}



	public class DerivativeType extends GenericFactory implements IXmlNode
	{
		public DerivativeType()
		{
			super(IXmlParser.Legs.class);
		}

		private String Code = null;
		private String Name = null;
		private String IsPriceInPercent = null;
		private String LegCount = null;
		private String IsBasic = null;
		private String UnderlyingClass = null;
		private String LastUpdateDateTime = null;

		private String ParameterString = null;

		List<IXmlParser.Legs> Legs = new ArrayList<IXmlParser.Legs>();
		
//		@Override
//		public String toString() {
//			StringBuilder sb = new StringBuilder();
//			sb.append("DerivativeType [Code=").append(Code)
//				.append(", Name=").append(Name)
//				.append(", IsPriceInPercent=").append(IsPriceInPercent)
//				.append(", LegCount=").append(LegCount)
//				.append(", IsBasic=").append(IsBasic)
//				.append(", UnderlyingClass=").append(UnderlyingClass)
//				.append(", LastUpdateDateTime=").append(LastUpdateDateTime)
//				.append(", ");
//			for (IXmlNode l: Legs) {
//				sb.append(l.toString()).append(", ");
//			}
//			sb.append("]");
//			return sb.toString();
//		}
		
		public String getCode()
		{
			return Code;
		}

		public String getName()
		{
			return Name;
		}

		public String getIsPriceInPercent()
		{
			return IsPriceInPercent;
		}

		public String getLegCount()
		{
			return LegCount;
		}

		public String getIsBasic()
		{
			return IsBasic;
		}

		public String getUnderlyingClass()
		{
			return UnderlyingClass;
		}

		public String getLastUpdateDateTime()
		{
			return LastUpdateDateTime;
		}

		public String getParameterString()
		{
			return ParameterString;
		}

		public List<IXmlParser.Legs> getLegs()
		{
			return Legs;
		}

		public void setCode(String code)
		{
			Code = code;
		}

		public void setName(String name)
		{
			Name = name;
		}

		public void setIsPriceInPercent(String isPriceInPercent)
		{
			IsPriceInPercent = isPriceInPercent;
		}

		public void setLegCount(String legCount)
		{
			LegCount = legCount;
		}

		public void setIsBasic(String isBasic)
		{
			IsBasic = isBasic;
		}

		public void setUnderlyingClass(String underlyingClass)
		{
			UnderlyingClass = underlyingClass;
		}

		public void setLastUpdateDateTime(String lastUpdateDateTime)
		{
			LastUpdateDateTime = lastUpdateDateTime;
		}

		public void setParameterString(String parameterString)
		{
			ParameterString = parameterString;
		}
		
//		@Override
//		public void parseNode(Element root) // root = <Legs>
//		{
//			parseAttribute(root);
//			
//			String nodeName = root.getNodeName();
//			
//			NodeList nodes = root.getChildNodes();
//			int lenNodes = nodes.getLength();
//			for (int l = 0; l < lenNodes; l++)
//			{ // elements
//				Node n = nodes.item(l);
//
//				if (n.getNodeType() == Node.ELEMENT_NODE)
//				{
//					nodeName = n.getNodeName();
////					try
////					{
////						Class<?> clazz = Class.forName("com.vectails.data.IXmlParser$" + nodeName);
////						if (IGenericFactory.class.isAssignableFrom(clazz))
////						{
//							Field field;
//							try
//							{
//								field = this.getClass().getDeclaredField(nodeName);
//
//								if (Collection.class.isAssignableFrom(field.getType()))
//								{
//									IXmlNode o = new IXmlParser.Legs();
//									o.parseNode((Element) n);
//									
//									Object obj = field.get(this);
//									Method m = field.getType().getDeclaredMethod("add", Object.class);
//									m.invoke(obj, o);
//								} else
//								{
//									Method setter = this.getClass().getMethod("set" + nodeName, field.getType());
//									setter.invoke(this, n.getTextContent());
//								}
//							} catch (Exception e)
//							{
//								System.out.println("nodeName="+nodeName);
//								e.printStackTrace();
//							}
////						}
////					} catch (ClassNotFoundException e)
////					{
////						// TODO Auto-generated catch block
////						e.printStackTrace();
////					}
//				}
//			}
//		}
	}
	
	public class Legs extends GenericFactory implements IXmlNode
	{
		List<IXmlParser.Leg> Leg = new ArrayList<IXmlParser.Leg>();
		
		public Legs()
		{
			super(Leg.class);
		}

//		@Override
//		public String toString()
//		{
//			StringBuilder sb = new StringBuilder();
//			sb.append(this.getClass().getSimpleName()).append(" [");
//
//			for (Field field : getClass().getDeclaredFields())
//			{
//				try
//				{
//					if (Collection.class.isAssignableFrom(field.getType()))
//					{
//						Object listObj = field.get(this);
//
//						Method mthGet = field.getType().getDeclaredMethod("iterator", null);
//						Iterator begin = (Iterator) mthGet.invoke(listObj, null);
//						for (Iterator it = begin; it.hasNext(); ) {
//							sb.append(it.next().toString()).append(", ");
//						}
//					} else
//					{
//						String nodeName = field.getName();
//						Method setter = this.getClass().getMethod("get" + nodeName, null);
//						String s = (String) setter.invoke(this, null);
//						sb.append(s).append(", ");
//					}
//
//				} catch (Exception e)
//				{
//					e.printStackTrace();
//				}
//			}
//
//			sb.append("]");
//			return sb.toString();
//		}
		
		
//		@Override
//		public void parseNode(Element root) // root = <Legs>
//		{
//			parseAttribute(root);
//
//			String nodeName = root.getNodeName();
//
//			NodeList nodes = root.getChildNodes();
//			int lenNodes = nodes.getLength();
//			for (int l = 0; l < lenNodes; l++)
//			{ // elements
//				Node n = nodes.item(l);
//
//				if (n.getNodeType() == Node.ELEMENT_NODE)
//				{
//					nodeName = n.getNodeName();
//					try
//					{
//						Field field = this.getClass().getDeclaredField(nodeName);
//
//						if (Collection.class.isAssignableFrom(field.getType()))
//						{
//							IXmlNode o = (IXmlNode) this.build();
//							o.parseNode((Element) n);
//
//							Object obj = field.get(this);
//							Method m = field.getType().getDeclaredMethod("add", Object.class);
//							m.invoke(obj, o);
//						} else
//						{
//							Method setter = this.getClass().getMethod("set" + nodeName, field.getType());
//							setter.invoke(this, n.getTextContent());
//						}
//					} catch (Exception e)
//					{
//						e.printStackTrace();
//					}
//				}
//			}
//		}
	}
	
public class Leg extends GenericFactory  implements IXmlNode
{

	// attributes
	private String Label = null;
	private String MultiUnderlyingItemType = null;
	private String MultiUnderlyingItemIndex = null;

	// elements
	private String Barrier = null;
	private String BarrierInPercent = null;
	private String Cap = null;
	private String Coupon = null;
	private String Delta = null;
	private String DerivativeType = null;
	private String DividendRequirement = null;
	private String EndOfBarrierDate = null;
	private String ExpiryDate = null;
	private String FutureBasis = null;
	private String FutureSpot = null;
	private String Garantee = null;
	private String KnockInBarrier = null;
	private String Leverage = null;
	private String LimitDown = null;
	private String LimitUp = null;
	private String Multiplier = null;
	private String Periodicity = null;
	private String QuantoCurrency = null;
	private String Currency = null;
	private String Radius = null;
	private String Rate = null;
	private String Rebate = null;
	private String RebateInPercent = null;
	private String ResetPeriodicity = null;
	private String Size = null;
	private String Spot = null;
	private String StartDate = null;
	private String Strike = null;
	private String StrikeInPercent = null;
	private String Until = null;
	// not in spec v1.8
	private String NAV = null;
	private String Frequency = null;

	public Leg()
	{
		super(Leg.class);
	}

	public void setLabel(String label)
	{
		Label = label;
	}

	public void setMultiUnderlyingItemType(String multiUnderlyingItemType)
	{
		MultiUnderlyingItemType = multiUnderlyingItemType;
	}

	public void setMultiUnderlyingItemIndex(String multiUnderlyingItemIndex)
	{
		MultiUnderlyingItemIndex = multiUnderlyingItemIndex;
	}

	public void setBarrier(String barrier)
	{
		Barrier = barrier;
	}

	public void setBarrierInPercent(String barrierInPercent)
	{
		BarrierInPercent = barrierInPercent;
	}

	public void setCap(String cap)
	{
		Cap = cap;
	}

	public void setCoupon(String coupon)
	{
		Coupon = coupon;
	}

	public void setDelta(String delta)
	{
		Delta = delta;
	}

	public void setDerivativeType(String derivativeType)
	{
		DerivativeType = derivativeType;
	}

	public void setDividendRequirement(String dividendRequirement)
	{
		DividendRequirement = dividendRequirement;
	}

	public void setEndOfBarrierDate(String endOfBarrierDate)
	{
		EndOfBarrierDate = endOfBarrierDate;
	}

	public void setExpiryDate(String expiryDate)
	{
		ExpiryDate = expiryDate;
	}

	public void setFutureBasis(String futureBasis)
	{
		FutureBasis = futureBasis;
	}

	public void setFutureSpot(String futureSpot)
	{
		FutureSpot = futureSpot;
	}

	public void setGarantee(String guarantee)
	{
		Garantee = guarantee;
	}

	public void setKnockInBarrier(String knockInBarrier)
	{
		KnockInBarrier = knockInBarrier;
	}

	public void setLeverage(String leverage)
	{
		Leverage = leverage;
	}

	public void setLimitDown(String limitDown)
	{
		LimitDown = limitDown;
	}

	public void setLimitUp(String limitUp)
	{
		LimitUp = limitUp;
	}

	public void setMultiplier(String multiplier)
	{
		Multiplier = multiplier;
	}

	public void setPeriodicity(String periodicity)
	{
		Periodicity = periodicity;
	}

	public void setQuantoCurrency(String quantoCurrency)
	{
		QuantoCurrency = quantoCurrency;
	}

	public void setCurrency(String currency)
	{
		Currency = currency;
	}

	public void setRadius(String radius)
	{
		Radius = radius;
	}

	public void setRate(String rate)
	{
		Rate = rate;
	}

	public void setRebate(String rebate)
	{
		Rebate = rebate;
	}

	public void setRebateInPercent(String rebateInPercent)
	{
		RebateInPercent = rebateInPercent;
	}

	public void setResetPeriodicity(String resetPeriodicity)
	{
		ResetPeriodicity = resetPeriodicity;
	}

	public void setSize(String size)
	{
		Size = size;
	}

	public void setSpot(String spot)
	{
		Spot = spot;
	}

	public void setStartDate(String startDate)
	{
		StartDate = startDate;
	}

	public void setStrike(String strike)
	{
		Strike = strike;
	}

	public void setStrikeInPercent(String strikeInPercent)
	{
		StrikeInPercent = strikeInPercent;
	}

	public void setUntil(String until)
	{
		Until = until;
	}

	public void setNAV(String nAV)
	{
		NAV = nAV;
	}

	public void setFrequency(String frequency)
	{
		Frequency = frequency;
	}

//	@Override
//	public String toString()
//	{
//		return "Leg [Label=" + Label + ", MultiUnderlyingItemType=" + MultiUnderlyingItemType
//				+ ", MultiUnderlyingItemIndex=" + MultiUnderlyingItemIndex + ", Barrier=" + Barrier
//				+ ", BarrierInPercent=" + BarrierInPercent + ", Cap=" + Cap + ", Coupon=" + Coupon + ", Delta=" + Delta
//				+ ", DerivativeType=" + DerivativeType + ", DividendRequirement=" + DividendRequirement
//				+ ", EndOfBarrierDate=" + EndOfBarrierDate + ", ExpiryDate=" + ExpiryDate + ", FutureBasis="
//				+ FutureBasis + ", FutureSpot=" + FutureSpot + ", Garantee=" + Garantee + ", KnockInBarrier="
//				+ KnockInBarrier + ", Leverage=" + Leverage + ", LimitDown=" + LimitDown + ", LimitUp=" + LimitUp
//				+ ", Multiplier=" + Multiplier + ", Periodicity=" + Periodicity + ", QuantoCurrency=" + QuantoCurrency
//				+ ", Currency=" + Currency + ", Radius=" + Radius + ", Rate=" + Rate + ", Rebate=" + Rebate
//				+ ", RebateInPercent=" + RebateInPercent + ", ResetPeriodicity=" + ResetPeriodicity + ", Size=" + Size
//				+ ", Spot=" + Spot + ", StartDate=" + StartDate + ", Strike=" + Strike + ", StrikeInPercent="
//				+ StrikeInPercent + ", Until=" + Until + ", NAV=" + NAV + ", Frequency=" + Frequency + "]";
//	}
	
//	@Override
//	public String toString()
//	{
//		StringBuilder sb = new StringBuilder();
//		sb.append(this.getClass().getSimpleName()).append(" [");
//
//		for (Field field : getClass().getDeclaredFields())
//		{
//			try
//			{
//				if (Collection.class.isAssignableFrom(field.getType()))
//				{
//					Object listObj = field.get(this);
//
//					Method mthGet = field.getType().getDeclaredMethod("iterator", null);
//					Iterator begin = (Iterator) mthGet.invoke(listObj, null);
//					for (Iterator it = begin; it.hasNext(); ) {
//						sb.append(it.next().toString()).append(", ");
//					}
//				} else
//				{
//					String nodeName = field.getName();
//					Method setter = this.getClass().getMethod("get" + nodeName, null);
//					String s = (String) setter.invoke(this, null);
//					sb.append(s).append(", ");
//				}
//
//			} catch (Exception e)
//			{
//				e.printStackTrace();
//			}
//		}
//
//		sb.append("]");
//		return sb.toString();
//	}
	
	public String getLabel()
	{
		return Label;
	}

	public String getMultiUnderlyingItemType()
	{
		return MultiUnderlyingItemType;
	}

	public String getMultiUnderlyingItemIndex()
	{
		return MultiUnderlyingItemIndex;
	}

	public String getBarrier()
	{
		return Barrier;
	}

	public String getBarrierInPercent()
	{
		return BarrierInPercent;
	}

	public String getCap()
	{
		return Cap;
	}

	public String getCoupon()
	{
		return Coupon;
	}

	public String getDelta()
	{
		return Delta;
	}

	public String getDerivativeType()
	{
		return DerivativeType;
	}

	public String getDividendRequirement()
	{
		return DividendRequirement;
	}

	public String getEndOfBarrierDate()
	{
		return EndOfBarrierDate;
	}

	public String getExpiryDate()
	{
		return ExpiryDate;
	}

	public String getFutureBasis()
	{
		return FutureBasis;
	}

	public String getFutureSpot()
	{
		return FutureSpot;
	}

	public String getGarantee()
	{
		return Garantee;
	}

	public String getKnockInBarrier()
	{
		return KnockInBarrier;
	}

	public String getLeverage()
	{
		return Leverage;
	}

	public String getLimitDown()
	{
		return LimitDown;
	}

	public String getLimitUp()
	{
		return LimitUp;
	}

	public String getMultiplier()
	{
		return Multiplier;
	}

	public String getPeriodicity()
	{
		return Periodicity;
	}

	public String getQuantoCurrency()
	{
		return QuantoCurrency;
	}

	public String getCurrency()
	{
		return Currency;
	}

	public String getRadius()
	{
		return Radius;
	}

	public String getRate()
	{
		return Rate;
	}

	public String getRebate()
	{
		return Rebate;
	}

	public String getRebateInPercent()
	{
		return RebateInPercent;
	}

	public String getResetPeriodicity()
	{
		return ResetPeriodicity;
	}

	public String getSize()
	{
		return Size;
	}

	public String getSpot()
	{
		return Spot;
	}

	public String getStartDate()
	{
		return StartDate;
	}

	public String getStrike()
	{
		return Strike;
	}

	public String getStrikeInPercent()
	{
		return StrikeInPercent;
	}

	public String getUntil()
	{
		return Until;
	}

	public String getNAV()
	{
		return NAV;
	}

	public String getFrequency()
	{
		return Frequency;
	}

//		@Override
//		public void parseNode(Element root) // root = <Legs>
//		{
//			parseAttribute(root);
//
//			String nodeName = root.getNodeName();
//
//			NodeList nodes = root.getChildNodes();
//			int lenNodes = nodes.getLength();
//			for (int l = 0; l < lenNodes; l++)
//			{ // elements
//				Node n = nodes.item(l);
//
//				if (n.getNodeType() == Node.ELEMENT_NODE)
//				{
//					nodeName = n.getNodeName();
//					try
//					{
//						Field field = this.getClass().getDeclaredField(nodeName);
//
//						if (Collection.class.isAssignableFrom(field.getType()))
//						{
//							IXmlNode o = (IXmlNode) this.build();
//							o.parseNode((Element) n);
//
//						} else
//						{
//							Method setter = this.getClass().getMethod("set" + nodeName, field.getType());
//							setter.invoke(this, n.getTextContent());
//						}
//					} catch (Exception e)
//					{
//						e.printStackTrace();
//					}
//				}
//			}
//		}
	
	// public default void parseNode(Element root) { // root = <Legs>
	//
	// String nodeName = root.getNodeName();
	// System.out.println(nodeName);
	//
	// NodeList nodes = root.getChildNodes();
	// int lenNodes = nodes.getLength();
	// for (int l = 0; l < lenNodes; l++) { // elements
	// Node n = nodes.item(l);
	//
	// if (n.getNodeType() == Node.ELEMENT_NODE) {
	// parseNode((Element)n);
	// }
	// }
	// }
}


}
